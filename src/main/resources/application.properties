spring.application.name=financello-api
server.servlet.context-path=/api/v1
server.port=8080
# Configuración de Base de Datos
spring.datasource.url=jdbc:postgresql://localhost:5432/financello_db
spring.datasource.username=postgres
spring.datasource.password=adminadmin
spring.datasource.driver-class-name=org.postgresql.Driver

# Propiedades de JPA/Hibernate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.jpa.properties.hibernate.default_schema=public

# Configuración de Data Test
spring.sql.init.mode=never
spring.sql.init.data-locations=classpath:data-test.sql

spring.datasource.hikari.connection-init-sql= SET NAMES 'UTF8'

security.public-paths = /api/v1/auth/login, /api/v1/auth/signup
###
# Instrucciones para la creación de datos de prueba en PgAdmin

# Cambia el valor de: spring.datasource.password={TuContraseñaDePgAdmin}.
# Por lo general es 'admin' o 'postgres', pero si lo cambiaste (como yo), debes actualizarlo.
# Asegúrate también de que el username sea 'postgres':
# spring.datasource.username=postgres

# Ahora con el JPA y la creación de las tablas en PgAdmin.
# Si no tienen idea de esto, mejor lean:
# spring.jpa.hibernate.ddl-auto=update ? esta línea carga las entidades del proyecto al PgAdmin.

# Los valores que pueden usar acá son:
# - create-drop ? crea desde 0 las tablas, más no las columnas. Útil cuando los IDs están desfasados (por ejemplo, van por 30 y quieres volver a 1).
# - update ? si ya tienes las tablas creadas, lo que sige es actualizar las columnas, bueno de eso se encarga este valor, si tienes la necesidad de crear una nueva columna y quieres pasarla al Pgadmin, esto servira

# Ahora va la parte de cargar los datos de prueba:
# spring.sql.init.mode=always  <--- esta línea se encarga de eso
# spring.sql.init.data-locations=classpath:data-test.sql

# Solo vamos a usar la línea del "mode", si saben inglés se imaginaran como funciona.
# Los valores posibles son:
# - never ? nunca cargará el archivo SQL (útil cuando ya tienes los datos creados y no quieres errores por duplicados).
# - always ? siempre lo carga (solo úsenlo una vez para insertar los datos, luego cambien a 'never').

# ? Puede que se pregunten, ¿cómo deben cambiar estas líneas según la fase en la que estén? Acá va un ejemplo:

# ? Creación de tablas (1era fase): osea que no tienen nada en el pgAdmin y recien estan queriendo crearlas.
# spring.jpa.hibernate.ddl-auto=create-drop  <-- para poder crear las tablas en el pgAdmin
# spring.sql.init.mode=never  <-- esto no debe estar en always porque aun no estan creadas las columnas

# ? Actualización de columnas (2da fase): ya tienen las tablas y quieren agregar/modificar columnas.
# spring.jpa.hibernate.ddl-auto=update  <-- para actualizarlas porque, update= actualizar
# spring.sql.init.mode=never
# (En esta parte puede que 'always' funcione, no estoy seguro, pero no lo comprobare. Si lo ponen y les falla, ya saben por qué).

# ? Insertar datos de prueba (3ra fase): Ahora sí colocar los datos de prueba
# spring.jpa.hibernate.ddl-auto=update  <-- no se preocupen por este valor de ahora en adelante, no va a fastidiar
# spring.sql.init.mode=always  <-- ahora si se podra, si es que lo han hecho bien
# (Después de esto, cambien a: spring.sql.init.mode=never, para que no lo vuelva a ejecutar).
###
